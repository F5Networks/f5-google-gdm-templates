## @package data_gen
#  Data generation, either file dump or a daemon that servers a name pipe
#
#  More details
import os, signal, logging, datetime, select, getpass
import argparse
import yaml
import daemon
from lockfile.pidlockfile import PIDLockFile

# TODO: add this to command line or config file
logfile = './log/data_gen.log'
fifofile = './var/dynamic_data.yaml'
datafile = './tmp/generated_data.yaml'

parser = argparse.ArgumentParser()
parser.add_argument('--server', default=False, action='store_true', help="Runs as a daemon on a named pipe to provide dynamic data via file.")

args = parser.parse_args()

working_directory = os.getcwd()

# TODO: add optiong logging and command line to control it to rest of script besides server

## prepares the file system by making the directories and fifos needed to run
def prepare_filesystem():
    if os.path.exists('var') is not True:
        os.mkdir('var')
    if os.path.exists('log') is not True:
        os.mkdir('log')
    if os.path.exists('tmp') is not True:
        os.mkdir('tmp')
    if args.server:
        if os.path.exists(fifofile) is not True:
            os.mkfifo(fifofile)
    else:
        if os.path.exists('tmp') is not True:
            os.mkdir('tmp')

## produce the data required for the build
def produce_data():
    # example - put dynamic data generation here
    base = {
        'name': 'base',
        'script': os.path.basename(__file__),
        'autogenerated': True,
        'timestamp': datetime.datetime.utcnow(),
        'os': os.uname()[3],
        'user': getpass.getuser(),
    }
    return yaml.dump(base, default_flow_style=False)

## Serve the data via fifo.
#
#  sets up logging to a file and catches any exceptions.
#  expected to run inside a python-daemon.DaemonContext
def serve_data():
    logging.basicConfig(filename=logfile, filemode="w", level=logging.DEBUG)
    logging.info("serve_data entered")
    try:
        while True:
            f = open(fifofile,'w')
            # bleh, this is getting too complex, just freakin write the file
            readable, writable, exceptional = select.select([],[f],[])
            for s in writable:
                if s is f:
                    f.write(produce_data())
                    f.close()
                    logging.debug("answered request")
    except Exception as xx:
        logging.error("Daemon had problems, exiting...")
        logging.error(print(xx))


## handles SIGTERM by cleaning up pid file, etc
def program_cleanup(signum, frame):
    logging.info("Daemon cleaning up and exiting cleanly")
    exit(0)


## handles misc SIGNALS
def program_crash(signum, frame):
    logging.info("Daemon crashed: ")
    exit(1)


## Runs the work in a daemon which dynamically generates data when a named pipe is read
def daemonize():
    context = daemon.DaemonContext(working_directory=working_directory,
                               pidfile=PIDLockFile("./var/data_gen.pid"),
                               detach_process=True,
                               )
    context.signal_map = {
        signal.SIGTERM: program_cleanup,
        signal.SIGINT: program_crash,
        signal.SIGHUP: program_crash,
    }

    with context:
        serve_data()

## Main
def main():
    prepare_filesystem()
    if args.server:
        daemonize()
    else:
        f = open(datafile,'w')
        f.write(produce_data())
        f.close()



## in case anyone ever imports it to use it's functions
if __name__ == "__main__":
    main()
